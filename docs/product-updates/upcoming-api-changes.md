---
sidebar_position: 1
---

# Upcoming API Changes

**Learn about scheduled API changes**
<hr />

Here is a list of changes to the API that we want you to be aware of well in advance as they may affect how you use Clarifai's platform. These changes include scheduled downtime and other improvements in stability, performance or functionality of the Clarifai platform in order to better serve you as a customer. 

Some of these changes may not be backward compatible and thus require you to update how you call our APIs. We created this page with the mindset of being as transparent as possible so you can plan any corresponding changes in advance and minimize any interruptions to your usage of Clarifai.

The dates listed in the following tables are the date we plan to make the change. We may actually make the change in the days following the specified date. However, to be safe, your client-side code needs updating before that date to minimize any downtime to your applications.

We will continue to update this page regularly, so a good way to always stay up to date is to watch our [documentation repo on GitHub](https://github.com/Clarifai/docs).

## Upcoming Changes
| Date | Change | Details |
| :--- | :--- | :--- |
| March 30th 2023 | **(Breaking change)**  <br /><br /> Critical changes to the use of PATs and API Keys|Previously, you could use API keys to access any model owned by the app scoped to the API key, as well as all `clarifai/main` models. Now, however, this can only be done with a PAT tied to your account. This allows us to improve both the security and efficiency of our platform.<br /><br /> <ul><li>You must now use [PATs](https://docs.clarifai.com/clarifai-basics/authentication/personal-access-tokens) to make inferences on resources that are outside the scope of your apps, such as Clarifai’s models and workflows. While using a PAT, you must also specify the `user_id` of the application owner, and the `app_id` of the application that you’re accessing. Previously, you could use the `user_id` and `app_id` of any application on the platform to access clarifai models in the "main" app; however, now it needs to be the `user_id` (_clarifai_) and `user_id` (_main_) associated with the application containing the model.</li><li>You will no longer be able to use [API Keys](https://docs.clarifai.com/clarifai-basics/authentication/app-specific-api-keys) to access resources outside the scope defined by that key. With a key, there is no need to specify the `user_id` or the `app_id` as they are already part of the key. API keys will function as normal when accessing resources within the scope defined by that key.</li><li>For example, this implies that you will no longer access Clarifai's models (such as those with `user_id` “clarifai” and `app_id` “main”) with API Keys. Instead, you will need to use a PAT while specifying Clarifai's `user_id` (_clarifai_) and `app_id` (_main_) in the request.</li><li>Workflows will **not** be affected in the same way. Workflows in your app referencing any public models, including Clarifai "main" models, will continue to work with API Key.</li></ul> **What you need to do** <ul><li>Ensure that you set the `PAT`, `user_id`, and `app_id` variables appropriately.</li></ul>|


## Completed Changes

| Date | Change | Details |
| :--- | :--- | :--- |
|January 26th 2023 | Deprecation of `closed_environment` in Favor of `enrich_dataset` For Creating Embedding-Classifier Models   | When using the **PostModels** endpoint to create a custom embedding-classifier model, you could include the `closed_environment` variable, as part of the `modelVersion.OutputInfo.OutputConfig` struct. <br /><br /> The variable accepted a Boolean value and specified whether a pre-stored dataset, of (usually) negative embeddings, should be added to the training process of your model. This generally leads to higher model accuracy without any additional effort on your end. <br /><br /> <ul><li> If `closed_environment` was set to `False`, which was the default action, we would try to use additional negative embeddings during the training process. _However, the default action would fail if the underlying base model did not have negative embeddings._ </li><li>If it was set to `True`, it meant that the user wanted a closed environment for the training and therefore we did not add additional negative embeddings. This worked for all embedding models.</li></ul> We plan to replace it with `enrich_dataset` that is specified inside `modelVersion.TrainInfo.Params` when creating embedding-classifiers, which is the only type of model that supports it. <br /><br /> The `enrich_dataset` variable will be implemented as an `ENUM` instead of a `BOOL` so that it can have two options: `Automatic` (default) and `Disabled`. <br /><br /> <ul><li>`Automatic` means that if there are negative embeddings for a base model, we will use them—and we won’t use them if they’re not available. _So, the training will not fail if the underlying embeddings do not have negative embeddings._</li><li>`Disabled` means that we should not use the negative embeddings whether they are available or not. </li></ul> That way, `enrich_dataset` fixes the problem with `closed_environment`. Previously, setting the `closed_environment` variable to `False` (the default value) would fail if the base model didn’t have the negatives for it. <br /><br /> This change will also affect the **PostModelVersions** endpoint. |
| January 20, 2023 |Critical Updates to Model and Model Version Endpoints|<h4>Old Behavior</h4><ul><li>Previously, using the **PostModels** endpoint to create a new model also created a placeholder version of the model with user-provided fields. And if the `model_type_id` of the model was trainable, then a new ModelVersion was created with UNTRAINED status by default. Otherwise, if the `model_type_id` was not trainable, then a new ModelVersion was created with TRAINED status.</li><li>Modifying a model's config settings requires using the **PatchModels** endpoint. It's how you previously changed the info fields, descriptions, notes, metadata for both models and model versions. If you were only patching fields that are informational about the model, and not the model version, a model version was not created. If you were patching a trainable model where the latest model version was trained, and you were only changing the `output_info`, a new trained model version was created with the new info. Otherwise, if you were patching a trainable model where the latest model version had not been trained, the created model version was marked as untrained by default. If you were patching an untrainable model type, the new created model version was marked as trained.</li><li>Previously, using the **PostModelVersions** endpoint automatically, by default, kicked off training the latest untrained model version—even though a user may not intend to train the latest version, which could unnecessarily incur training costs.</li><li>Previously, using the **PatchModelVersions** endpoint only patched a model versions' visibility, metadata, license, or description—while maintaining the model version's status.</li><br /></ul><h4>New Behavior</h4><ul><li>**PostModels** will create new models but not create new model versions. This means trainable models that have not yet been trained will require the additional step of calling **PostModelVersions**—while providing the `*_info` fields in the model version—to effect training.<li>**PostModelVersions** will allow users to give information specific to a model version. All the `*_info` fields—such as `output_info`, `input_info`, `train_info`, and `import_info`—will be migrated to the endpoint. This would minimize the confusion and difficulty of maintaining these endpoints. Users will be able patch model specific fields without worrying about model version fields being affected.</li></li><li>**PatchModels** will allow users to patch only the model level fields, nothing in the model version. Unnecessary model versions will no longer be created. This allows users to easily track persisted versions.</li><li>**PatchModelVersions** will be the new way to change most of the model version fields like gettable, metadata, license, description, notes, and `output_info` (not including concepts).</li><li>If users used `model.output_info.output_config` when inferencing, they will have to change that to `model.model_version.output_info.output_config`.</li></ul>|
| January 4th 2023  |Exclusion of Some Fields From **PostModelOutputs** and **PostWorkflowResults** Prediction Responses|<ul><li>When using the **PostModelOutputs** endpoint or the **PostWorkflowResults** endpoint to make a prediction call, the entire model information, including all hyperparameters, is included for each output in the response. This is extremely verbose and also unnecessary, as the same information appears repeatedly throughout the response. It also impacts network usage, ease of viewing and processing the results and debugging by the user, and other performances.</li><li> Model description, notes and related model info fields are to be excluded from **PostModelOutputs** and **PostWorkflowResults** prediction responses. The model and model version ids are still available in the responses. If you need more model info than that available from any of the responses, you can look up the info by model id using the **GetModel** endpoint.</li></ul>|
| November 22, 2022 |Deprecation of `POST /searches` | The generic search API will be deprecated in favor of `POST /inputs/searches` and `POST /annotations/searches`. `POST /searches` will still be supported for now, but will not receive any feature updates so users are suggested to use the newer search endpoints. |
| January 20, 2022 |Deprecation of `name` and `display_name` |  To make Clarifai Model IDs more readable and user friendly, we plan to make the following API/UI changes during the week of Jan 17th. Please see user impact and suggestions below and contact [support@clarifai.com](mailto:support@clarifai.com) if you have any questions. <br></br><br></br> The old `user_unique_id` will still be usable in all queries, but the responses will be filled with the new `v2_user_unique_id`. `name` and `display_name` are deprecated in the API and UI, and `user_unique_id` will soon be deprecated as well so users are suggested to use new model id field `v2_user_unique_id`. |
| November 24, 2021. 9:00am ET | Deprecation of type option | The `type` option in POST /models and /models/searches reuest will no longer be supported and will be removed from our API after this point in time. `model_type_id` is in use for model type references. |
| February 12, 2021. 9:00am ET | Deprecation of `delete_all` option | The `delete_all` option in DELETE /inputs request will no longer be supported and will be removed from our API after this point in time. You can delete inputs by id. Each request can have at most 128 ids. |
| October 16, 2020. 9:00am ET | Deprecation of Demographics Model |  To reduce the risk of race bias in our own models, we have constructed a new approach to visual recognition of race. We've also divided age, race and gender recognition into separate models, and then packaged the models into a new public Demographics Workflow. This new approach provides much more flexibility, and makes outputs easier to parse. We will be retiring the current demographics model on October 16th, 2020. Please reference this [blog post](https://www.clarifai.com/blog/new-demographics-workflow), and our [API documentation](https://docs.clarifai.com/api-guide/api-overview) for more information about how you can update your code to take advantage of the new workflow. |
| October 20, 2020. 9:00am ET | Model Training Do Not Wait For Inputs To Be Processed | Currently, when we train a context-based classifier model, we wait for all inputs to be added to your app before a model version is created and processed, with a 1 hour training timeout. In the future, we will use any available inputs and annotations that are available at the time a model version is created for training. If the input is pending or in progress, those inputs and associated annotations will not be used for training. You can use [https://api.clarifai.com/v2/inputs/status](https://api.clarifai.com/v2/inputs/status) to check input counts for each status. |
| February 27, 2020. 9:00am ET | [Deprecation of Face object from API](upcoming-api-changes.md#deprecation-face-from-api) | The Face object in our API responses will be deprecated in favor of a list of Concepts that other model types return. This should only effect users of the Celebrity, Demographics, or custom face recognition models where the `data.face` attributes like `data.face.identity`, `data.face.age_appearance`, `data.face.gender_appearance`, and `data.face.multicultural_appearance` will now be returned in the list of `data.concepts` Concept object. The API will return both for a while during the transition to give you time to update your code away from using the `data.face` objects altogether. We are doing this to simplify the API interface and make it more easily compatible for advanced functionality that is coming soon in workflows! The custom face recognition and celebrity models are a simple change to just access the new `data.concepts` field, but the demographics model is a more fundamental change away from having three distinct lists of concept to a single list. In order to cope with this, we have introduced a `vocab_id` field in each `data.concepts` entry that is returned by the demographics model so that you can distinguish `age_appearance`, `gender_appearance` and `multicultural_appearance`.To convert new format to old format, check python example [here.](https://github.com/Clarifai/docs/tree/master/examples/deprecate_face_object). |
| February 24, 2020. 9:00am ET | Consolidation of Input Related Status Codes |  As we support more media types, it is impractical to have status codes for each. Thus status codes will now be prefixed `INPUT_...` rather than `INPUT_IMAGE_...` or `INPUT_VIDEO_...`. We will maintain the int value for the `INPUT_IMAGE_...` prefixed statuses, but no longer support the int values associated with statuses prefixed `INPUT_VIDEO...`. |
| February 12, 2020. 9:00am ET | Deprecation of Face model type names | The `facedetect*` model types will be deprecated in favor of their more general `detect*` counterparts. For example these would be the changes of model type: `facedetect` -&gt; `detect` `facedetect-identity` -&gt; `detect-concept` `facedetect-demographics` -&gt; `detect-concept` `facedetect-embed` -&gt; `detect-embed` This change is to unify the APIs around face products and object detection products so that they are compatible everywhere either is used. |
| February 3, 2020. 9:00am ET | `PATCH /inputs` overwrite action change | The overwrite action when patching inputs currently has some inconsistent behavior. If you patch `input.data.metadata` or `input.data.geo` fields on an input that has `input.data.concepts` already added to it, these concepts will remain after the patch even though the patch action was `overwrite`.  Going forward, the overwrite behavior will overwrite the entire `data` object with what is included in the `PATCH /inputs` API call. Therefore if concepts are not provided in the patch call, but were originally on that input, they will be erased \(overwritten with an empty list of concepts\). You can maintain the current behvaiour by always sending back the complete `data` object from `GET /input/{input_id}` along with any modification to it if you are using the `overwrite` action.   Update: this change has become more complicated than originally expected and we may not undergo it after all, more to come in future. Still a good idea to update your PATCH calls to use the `merge` or `remove` actions instead of `overwrite` due to `overwrite`'s inconsistency. |
| February 1, 2020. 9:00am ET | Deprecation of Focus Model | The Focus model will no longer be supported and will be removed from our API after this point in time. If you have requests for recognizing focus and blurry regions within images please contact sales@clarifai.com so that we can help you directly. |
| November 20, 2019. 9:00am ET | `image.crop` argument will be deprecated | In some requests we used to allow cropping of images during the request using the `image.crop` field. This was for convenience only, but in reality is was rarely ever used and significantly complicates the processing pipelines under the hood. Therefore, we will no longer support the `image.crop` field in any requests that used to accept it.   If you want to have similar behavior please crop the images on the client side and send the cropped bytes as base64 encoded image data. |
| September 30, 2019. 5:00pm ET | `DELETE /inputs` will only operate asynchronously | Along the same lines as `POST /inputs` becoming completely asynchronous, we are cleaning up some inconsistent behavior in the API for deleting inputs. Previously, when a single image is deleted with `DELETE /inputs` or `DELETE /inputs/{input_id}` it was a synchronous operation, but when a batch of images were deleted it was asynchronous. We are making both asynchronous. This allows us to provide more advanced functionality with workflows that index your inputs.  What this means for your code is if you application relies on the input having been deleted when the `DELETE /inputs` or `DELETE /inputs/{input_id}` calls return, you now need to add a second call to `GET /inputs/{input_id}` in order to check that it fails with a not found error. |
| September 24, 2019. 5:00pm ET | `POST /inputs` will only operate asynchronously | We are cleaning up some inconsistent behavior in the API where a single image added with `POST /inputs` was a synchronous operation, but a batch of images was asynchronous. We are making both asynchronous. This allows us to provide more advanced functionality with workflows that index your inputs.  What this means for your code is if you application relies on added inputs having already been indexed when the `POST /inputs` call returns, you now need to add a second call to `GET /inputs/{input_id}` in order to check the status of the input you just added to look for 30000 \(INPUT\_IMAGE\_DOWNLOAD\_SUCCESS\) status code. |
| September 11, 2019. 9:00am ET | Scheduled Database Downtime | We plan to upgrade our database to make it faster and provide more space for your applications. We expect a few minutes of downtime during this upgrade but you should plan for up to an hour of downtime in case things don't go as expected. This will primarily affect the following uses of our platform: POST/GET/PATCH/DELETE inputs, Search, Custom Training, Model Evaluation |
