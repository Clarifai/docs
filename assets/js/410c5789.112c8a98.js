"use strict";(self.webpackChunkdocs_new=self.webpackChunkdocs_new||[]).push([[876],{15680:(e,n,t)=>{t.d(n,{xA:()=>s,yg:()=>g});var a=t(96540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var d=a.createContext({}),p=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},s=function(e){var n=p(e.components);return a.createElement(d.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,d=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),c=p(t),m=i,g=c["".concat(d,".").concat(m)]||c[m]||u[m]||o;return t?a.createElement(g,r(r({ref:n},s),{},{components:t})):a.createElement(g,r({ref:n},s))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var d in n)hasOwnProperty.call(n,d)&&(l[d]=n[d]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},96721:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=t(58168),i=(t(96540),t(15680));const o={description:"Learn about deprecation of `closed_environment`",sidebar_position:-4},r="Deprecation of closed_environment in favor of enrich_dataset",l={unversionedId:"product-updates/upcoming-api-changes/closed-environment",id:"product-updates/upcoming-api-changes/closed-environment",title:"Deprecation of closed_environment in favor of enrich_dataset",description:"Learn about deprecation of `closed_environment`",source:"@site/docs/product-updates/upcoming-api-changes/closed-environment.md",sourceDirName:"product-updates/upcoming-api-changes",slug:"/product-updates/upcoming-api-changes/closed-environment",permalink:"/product-updates/upcoming-api-changes/closed-environment",draft:!1,editUrl:"https://github.com/Clarifai/docs/blob/main/docs/product-updates/upcoming-api-changes/closed-environment.md",tags:[],version:"current",sidebarPosition:-4,frontMatter:{description:"Learn about deprecation of `closed_environment`",sidebar_position:-4},sidebar:"tutorialSidebar",previous:{title:"Changes to Use of PATs and API Keys",permalink:"/product-updates/upcoming-api-changes/pat-api-keys"},next:{title:"Updates to Model and Model Version Endpoints",permalink:"/product-updates/upcoming-api-changes/model-version-endpoints"}},d={},p=[{value:"Date",id:"date",level:2},{value:"Change",id:"change",level:2},{value:"Details",id:"details",level:2}],s={toc:p},c="wrapper";function u(e){let{components:n,...t}=e;return(0,i.yg)(c,(0,a.A)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"deprecation-of-closed_environment-in-favor-of-enrich_dataset"},"Deprecation of ",(0,i.yg)("inlineCode",{parentName:"h1"},"closed_environment")," in favor of ",(0,i.yg)("inlineCode",{parentName:"h1"},"enrich_dataset")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Learn about deprecation of ",(0,i.yg)("inlineCode",{parentName:"strong"},"closed_environment"))),(0,i.yg)("hr",null),(0,i.yg)("h2",{id:"date"},"Date"),(0,i.yg)("p",null,"January 26th, 2023"),(0,i.yg)("h2",{id:"change"},"Change"),(0,i.yg)("p",null,"Deprecation of ",(0,i.yg)("inlineCode",{parentName:"p"},"closed_environment")," in favor of ",(0,i.yg)("inlineCode",{parentName:"p"},"enrich_dataset")," for creating embedding-classifier models "),(0,i.yg)("h2",{id:"details"},"Details"),(0,i.yg)("p",null,"When using the ",(0,i.yg)("strong",{parentName:"p"},"PostModels")," endpoint to create a custom embedding-classifier model, you could include the ",(0,i.yg)("inlineCode",{parentName:"p"},"closed_environment")," variable, as part of the ",(0,i.yg)("inlineCode",{parentName:"p"},"modelVersion.OutputInfo.OutputConfig")," struct. "),(0,i.yg)("p",null,"The variable accepted a Boolean value and specified whether a pre-stored dataset, of (usually) negative embeddings, should be added to the training process of your model. This generally leads to higher model accuracy without any additional effort on your end. "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"If ",(0,i.yg)("inlineCode",{parentName:"p"},"closed_environment")," was set to ",(0,i.yg)("inlineCode",{parentName:"p"},"False"),", which was the default action, we would try to use additional negative embeddings during the training process. ",(0,i.yg)("em",{parentName:"p"},"However, the default action would fail if the underlying base model did not have negative embeddings.")," ")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"If it was set to ",(0,i.yg)("inlineCode",{parentName:"p"},"True"),", it meant that the user wanted a closed environment for the training and therefore we did not add additional negative embeddings. This worked for all embedding models."))),(0,i.yg)("p",null,"We plan to replace it with ",(0,i.yg)("inlineCode",{parentName:"p"},"enrich_dataset")," that is specified inside ",(0,i.yg)("inlineCode",{parentName:"p"},"modelVersion.TrainInfo.Params")," when creating embedding-classifiers, which is the only type of model that supports it. "),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"enrich_dataset")," variable will be implemented as an ",(0,i.yg)("inlineCode",{parentName:"p"},"ENUM")," instead of a ",(0,i.yg)("inlineCode",{parentName:"p"},"BOOL")," so that it can have two options: ",(0,i.yg)("inlineCode",{parentName:"p"},"Automatic")," (default) and ",(0,i.yg)("inlineCode",{parentName:"p"},"Disabled"),". "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"Automatic")," means that if there are negative embeddings for a base model, we will use them\u2014and we won\u2019t use them if they\u2019re not available. ",(0,i.yg)("em",{parentName:"p"},"So, the training will not fail if the underlying embeddings do not have negative embeddings."))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"Disabled")," means that we should not use the negative embeddings whether they are available or not. "))),(0,i.yg)("p",null,"That way, ",(0,i.yg)("inlineCode",{parentName:"p"},"enrich_dataset")," fixes the problem with ",(0,i.yg)("inlineCode",{parentName:"p"},"closed_environment"),". Previously, setting the ",(0,i.yg)("inlineCode",{parentName:"p"},"closed_environment")," variable to ",(0,i.yg)("inlineCode",{parentName:"p"},"False")," (the default value) would fail if the base model didn\u2019t have the negatives for it. "),(0,i.yg)("p",null,"This change will also affect the ",(0,i.yg)("strong",{parentName:"p"},"PostModelVersions")," endpoint."))}u.isMDXComponent=!0}}]);