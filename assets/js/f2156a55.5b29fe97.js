"use strict";(self.webpackChunkdocs_new=self.webpackChunkdocs_new||[]).push([[9332],{78198:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>d,default:()=>f,frontMatter:()=>c,metadata:()=>u,toc:()=>h});var a=n(74848),r=n(28453),i=n(11470),s=n(19365),o=n(21432);const l="\"\"\"\nA script designed for running bulk NLP model predictions on a .csv file of text entries.\nIt requires the library clarifai_grpc (to install it: `pip install clarifai_grpc`).\n\nMandatory arguments:\n- a CSV file with a \"text\" column; additional columns will be included/returned in the output file\n- a Clarifai API KEY\n- the model ID of the NLP model that you wish to predict with\n- the specific model version ID for the above NLP model\n\nOptional/Default arguments:\n- the \"top n\" number of results to be returned from the model predictions. default 3. [1-200]\n- the batch size or number of inputs to send in per predict call. default 32. max 128.\n\nExample usage:\npython nlp_model_predicts --csv_file CSVFILE --api_key API_KEY --model_id MODEL_ID --model_version MODEL_VERSION\n\nExample input CSV file:\ntext,random_column_1\n\"The quick brown fox something something.\",perhaps_some_data\n\"The lazy dog is...\",some_other_data\n\nExample output CSV file:\ntext,predict_1_concept,predict_1_value\n\"The quick brown fox something something.\",predicted_concept,0.873\n\"The lazy dog is...\",predicted_concept,0.982\n\"\"\"\n\nimport argparse\nimport csv\nimport os\n\nfrom clarifai_grpc.channel.clarifai_channel import ClarifaiChannel\nfrom clarifai_grpc.grpc.api import resources_pb2, service_pb2, service_pb2_grpc\nfrom clarifai_grpc.grpc.api.status import status_code_pb2\n\n\ndef chunker(seq, size):\n    return (seq[pos:pos + size] for pos in range(0, len(seq), size))\n\n\ndef get_predict(texts, stub, model_id, model_version, auth_metadata, top_n):\n    \"\"\"\n    inputs:\n    \u2022 texts: a list of text to run predictions on\n    \u2022 auth_metadata: (('authorization', 'Key YOUR_API_KEY'),)\n    \u2022 top_n: integer for the desired max number of returned concepts [limit 20]\n\n    returns:\n    \u2022 the original text\n    \u2022 predict_n_concept : predicted concept ID\n    \u2022 predict_n_value   : predict concept value\n    \"\"\"\n\n    if len(texts) > 128:\n        raise Exception('Input length over maximum batch size. Please send in batches less than 128.')\n\n    inputs = [\n        resources_pb2.Input(data=resources_pb2.Data(text=resources_pb2.Text(raw=x)))\n        for x in texts\n    ]\n\n    # make the model predict request\n    request = service_pb2.PostModelOutputsRequest(\n        model_id=model_id,\n        version_id=model_version,\n        inputs=inputs,\n    )\n\n    response = stub.PostModelOutputs(request, metadata=auth_metadata)\n\n    if response.status.code != status_code_pb2.SUCCESS:\n        raise Exception(\"A failed response: \" + str(response.status) + \"\\n\\nFull response:\\n\" + str(response))\n\n    # parse results\n    list_of_dicts = []\n    for resp in response.outputs:\n        temp_dict = {\n            'text': resp.input.data.text.raw\n        }\n\n        for n in range(top_n):\n            try:\n                temp_dict['predict_{}_concept'.format(n + 1)] = resp.data.concepts[n].id\n                temp_dict['predict_{}_value'.format(n + 1)] = \"%.3f\" % resp.data.concepts[n].value\n            except Exception as e:\n                print(e)\n                break\n\n        list_of_dicts.append(temp_dict)\n\n    return list_of_dicts\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\n        'Given a CSV file with a \"text\" column, provide NLP model predictions.'\n    )\n    parser.add_argument('--api_key', required=True, help='the app\\'s API key', type=str)\n    parser.add_argument('--csv_file', required=True, help='the CSV file with texts', type=str)\n    parser.add_argument('--model_id', required=True, help='the model ID', type=str)\n    parser.add_argument(\n        '--model_version', required=True, help='the specific model version ID', type=str)\n    parser.add_argument(\n        '--top_n', default=3, type=int, help='num results returned. default 3. max 200.')\n    parser.add_argument(\n        '--batch_size', default=32, type=int, help='prediction batch size. default 32. max 128')\n\n    args = parser.parse_args()\n\n    # setup the gRPC channel\n    channel = ClarifaiChannel.get_json_channel()\n    stub = service_pb2_grpc.V2Stub(channel)\n    metadata = (('authorization', f'Key {YOUR_API_KEY}'.format(args.api_key)),)\n\n    texts = []\n    with open(args.csv_file) as f:\n        csv_reader = csv.DictReader(f)\n        for row in csv_reader:\n            if 'text' not in row:\n                raise Exception('The CSV file must contain column with a header named text')\n\n            texts.append(row['text'])\n\n    predicted_data = []\n    # run model predictions in batches\n    for i, texts_chunk in enumerate(chunker(texts, args.batch_size)):\n        print(\"Predicting chunk #\" + str(i + 1))\n        predicted_data.extend(get_predict(texts_chunk, stub, args.model_id, args.model_version, metadata, args.top_n))\n\n    output_name = os.path.splitext(args.csv_file)[0] + '_results.csv'\n    print('Results saved to {}'.format(output_name))\n\n    with open(output_name, 'w') as f:\n        csv_writer = csv.DictWriter(f, fieldnames=predicted_data[0].keys())\n        csv_writer.writeheader()\n        csv_writer.writerows(predicted_data)\n\n\nif __name__ == '__main__':\n    main()",c={description:"Enjoy the convenience of working with CSV files and text.",sidebar_position:4},d="Batch Predict CSV on Custom Text Model",u={id:"api-guide/advanced-topics/batch-predict-csv-on-custom-text-model",title:"Batch Predict CSV on Custom Text Model",description:"Enjoy the convenience of working with CSV files and text.",source:"@site/docs/api-guide/advanced-topics/batch-predict-csv-on-custom-text-model.md",sourceDirName:"api-guide/advanced-topics",slug:"/api-guide/advanced-topics/batch-predict-csv-on-custom-text-model",permalink:"/api-guide/advanced-topics/batch-predict-csv-on-custom-text-model",draft:!1,unlisted:!1,editUrl:"https://github.com/Clarifai/docs/blob/main/docs/api-guide/advanced-topics/batch-predict-csv-on-custom-text-model.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{description:"Enjoy the convenience of working with CSV files and text.",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Patching",permalink:"/api-guide/advanced-topics/patching"},next:{title:"Intelligent Document Processing",permalink:"/api-guide/advanced-topics/intelligent-document-processing"}},p={},h=[{value:"Example Usage",id:"example-usage",level:2}];function m(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"batch-predict-csv-on-custom-text-model",children:"Batch Predict CSV on Custom Text Model"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Enjoy the convenience of working with CSV files and text"})}),"\n",(0,a.jsx)("hr",{}),"\n",(0,a.jsx)(t.p,{children:"Below is a script that can be used to run predictions on a batch of text/sentences stored in a CSV file, using your custom text model."}),"\n",(0,a.jsxs)(t.p,{children:["To start, you'll need to create your own Custom Text Model, either via ",(0,a.jsx)(t.a,{href:"https://docs.clarifai.com/portal-guide/model/pcustom-model-walkthrough/",children:"our Portal"})," or ",(0,a.jsx)(t.a,{href:"https://docs.clarifai.com/api-guide/model/custom-model-walkthrough/",children:"using the API"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Make sure to record the model ID and version ID that you want to use (each model gets a version ID after being successfully trained), as well as the API key of the application in which the model exists."}),"\n",(0,a.jsx)(t.p,{children:'This script assumes that you have a CSV file which has one column named "text" where the text you want to run predictions on is. It\'ll output another CSV file containing the predicted concepts for each text, together with confidence values.'}),"\n","\n",(0,a.jsx)(i.A,{children:(0,a.jsx)(s.A,{value:"nlp_model_predicts.py",label:"nlp_model_predicts.py",default:!0,children:(0,a.jsx)(o.A,{className:"language-python",children:l})})}),"\n",(0,a.jsx)(t.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,a.jsx)(t.p,{children:'Let\'s say you have the following CSV file, and you want to predict whether the sentence is grammatically positive or negative for each text in a row. You first build a custom text model that was created to map text into two concepts: "positive" and "negative.'}),"\n",(0,a.jsxs)(t.p,{children:["See our ",(0,a.jsx)(t.a,{href:"https://docs.clarifai.com/api-guide/model/custom-text-model-walkthrough/",children:"Custom Text Model walkthrough"})," on how to do that via our API."]}),"\n",(0,a.jsx)(i.A,{children:(0,a.jsxs)(s.A,{value:"my_data.csv",label:"my_data.csv",default:!0,children:[(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'number,text\n1,"We have never been to Asia, nor have we visited Africa."\n2,"I am never at home on Sundays."\n3,"One small action would change her life, but whether it would be for better or for worse was yet to be determined."\n4,"The waitress was not amused when he ordered green eggs and ham."\n5,"In that instant, everything changed."\n'})}),(0,a.jsx)(t.p,{children:"With that, you can run the script on the CSV file in the following manner, which will produce a new CSV file."}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"python nlp_model_predicts.py --api_key YOUR_API_KEY --model_id YOUR_MODEL_ID --model_version YOUR_MODEL_VERSION_ID --csv_file my_data.csv --top_n 2\n"})})]})}),"\n",(0,a.jsx)(i.A,{children:(0,a.jsx)(s.A,{value:"my_data_results.csv",label:"my_data_results.csv",default:!0,children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'text,predict_1_concept,predict_1_value,predict_2_concept,predict_2_value\n"We have never been to Asia, nor have we visited Africa.",negative,1.000,positive,0.000\nI am never at home on Sundays.,negative,1.000,positive,0.000\n"One small action would change her life, but whether it would be for better or for worse was yet to be determined.",positive,1.000,negative,0.000\nThe waitress was not amused when he ordered green eggs and ham.,negative,1.000,positive,0.000\n"In that instant, everything changed.",positive,0.998,negative,0.002\n'})})})})]})}function f(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},19365:(e,t,n)=>{n.d(t,{A:()=>s});n(96540);var a=n(18215);const r={tabItem:"tabItem_Ymn6"};var i=n(74848);function s(e){let{children:t,hidden:n,className:s}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,s),hidden:n,children:t})}},11470:(e,t,n)=>{n.d(t,{A:()=>y});var a=n(96540),r=n(18215),i=n(23104),s=n(56347),o=n(205),l=n(57485),c=n(31682),d=n(70679);function u(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??function(e){return u(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}(n);return function(e){const t=(0,c.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function h(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const r=(0,s.W6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(r.location.search);t.set(i,e),r.replace({...r.location,search:t.toString()})}),[i,r])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,i=p(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[c,u]=m({queryString:n,groupId:r}),[f,_]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,i]=(0,d.Dv)(n);return[r,(0,a.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:r}),g=(()=>{const e=c??f;return h({value:e,tabValues:i})?e:null})();(0,o.A)((()=>{g&&l(g)}),[g]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!h({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),_(e)}),[u,_,i]),tabValues:i}}var _=n(92303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=n(74848);function b(e){let{className:t,block:n,selectedValue:a,selectValue:s,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),d=e=>{const t=e.currentTarget,n=l.indexOf(t),r=o[n].value;r!==a&&(c(t),s(r))},u=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},t),children:o.map((e=>{let{value:t,label:n,attributes:i}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:a===t?0:-1,"aria-selected":a===t,ref:e=>l.push(e),onKeyDown:u,onClick:d,...i,className:(0,r.A)("tabs__item",g.tabItem,i?.className,{"tabs__item--active":a===t}),children:n??t},t)}))})}function x(e){let{lazy:t,children:n,selectedValue:r}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:i.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r})))})}function w(e){const t=f(e);return(0,v.jsxs)("div",{className:(0,r.A)("tabs-container",g.tabList),children:[(0,v.jsx)(b,{...t,...e}),(0,v.jsx)(x,{...t,...e})]})}function y(e){const t=(0,_.A)();return(0,v.jsx)(w,{...e,children:u(e.children)},String(t))}}}]);