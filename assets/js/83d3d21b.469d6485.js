"use strict";(self.webpackChunkdocs_new=self.webpackChunkdocs_new||[]).push([[1303],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=a,f=d["".concat(l,".").concat(m)]||d[m]||c[m]||i;return n?o.createElement(f,r(r({ref:t},p),{},{components:n})):o.createElement(f,r({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var u=2;u<i;u++)r[u]=n[u];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8215:function(e,t,n){var o=n(7294);t.Z=function(e){var t=e.children,n=e.hidden,a=e.className;return o.createElement("div",{role:"tabpanel",hidden:n,className:a},t)}},6396:function(e,t,n){n.d(t,{Z:function(){return d}});var o=n(7462),a=n(7294),i=n(2389),r=n(9443);var s=function(){var e=(0,a.useContext)(r.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},l=n(3616),u=n(6010),p="tabItem_vU9c";function c(e){var t,n,i,r=e.lazy,c=e.block,d=e.defaultValue,m=e.values,f=e.groupId,h=e.className,_=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=m?m:_.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),b=(0,l.lx)(g,(function(e,t){return e.value===t.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===d?d:null!=(t=null!=d?d:null==(n=_.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(i=_[0])?void 0:i.props.value;if(null!==v&&!g.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+g.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var y=s(),k=y.tabGroupChoices,w=y.setTabGroupChoices,x=(0,a.useState)(v),C=x[0],N=x[1],O=[],T=(0,l.o5)().blockElementScrollPositionUntilNextRender;if(null!=f){var P=k[f];null!=P&&P!==C&&g.some((function(e){return e.value===P}))&&N(P)}var I=function(e){var t=e.currentTarget,n=O.indexOf(t),o=g[n].value;o!==C&&(T(t),N(o),null!=f&&w(f,o))},S=function(e){var t,n=null;switch(e.key){case"ArrowRight":var o=O.indexOf(e.currentTarget)+1;n=O[o]||O[0];break;case"ArrowLeft":var a=O.indexOf(e.currentTarget)-1;n=O[a]||O[O.length-1]}null==(t=n)||t.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,u.Z)("tabs",{"tabs--block":c},h)},g.map((function(e){var t=e.value,n=e.label,i=e.attributes;return a.createElement("li",(0,o.Z)({role:"tab",tabIndex:C===t?0:-1,"aria-selected":C===t,key:t,ref:function(e){return O.push(e)},onKeyDown:S,onFocus:I,onClick:I},i,{className:(0,u.Z)("tabs__item",p,null==i?void 0:i.className,{"tabs__item--active":C===t})}),null!=n?n:t)}))),r?(0,a.cloneElement)(_.filter((function(e){return e.props.value===C}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},_.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==C})}))))}function d(e){var t=(0,i.Z)();return a.createElement(c,(0,o.Z)({key:String(t)},e))}},8475:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return u},contentTitle:function(){return p},metadata:function(){return c},toc:function(){return d},default:function(){return f}});var o=n(7462),a=n(3366),i=(n(7294),n(3905)),r=n(6396),s=n(8215),l=["components"],u={description:"Capture information from an organization's form that are stored as PDF documents.",sidebar_position:5},p="Intelligent Document Processing",c={unversionedId:"api-guide/advanced-topics/intelligent-document-processing",id:"api-guide/advanced-topics/intelligent-document-processing",title:"Intelligent Document Processing",description:"Capture information from an organization's form that are stored as PDF documents.",source:"@site/docs/api-guide/advanced-topics/intelligent-document-processing.md",sourceDirName:"api-guide/advanced-topics",slug:"/api-guide/advanced-topics/intelligent-document-processing",permalink:"/docs/api-guide/advanced-topics/intelligent-document-processing",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api-guide/advanced-topics/intelligent-document-processing.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{description:"Capture information from an organization's form that are stored as PDF documents.",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Batch Predict CSV on Custom Text Model",permalink:"/docs/api-guide/advanced-topics/batch-predict-csv-on-custom-text-model"},next:{title:"Clarifai Portal Basics",permalink:"/docs/portal-guide/portal-overview"}},d=[{value:"Introduction",id:"introduction",children:[{value:"The Use Case",id:"the-use-case",children:[],level:3},{value:"Assumptions",id:"assumptions",children:[],level:3}],level:2},{value:"Setup",id:"setup",children:[],level:2},{value:"Full implementation",id:"full-implementation",children:[],level:2}],m={toc:d};function f(e){var t=e.components,n=(0,a.Z)(e,l);return(0,i.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"intelligent-document-processing"},"Intelligent Document Processing"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In this series of posts, advanced users at Clarifai will present working solutions to help you kick-start your own AI solutions.")),(0,i.kt)("h3",{id:"the-use-case"},"The Use Case"),(0,i.kt)("p",null,"There is an a problem facing many organizations as they attempt to modernize: digitizing documents.\nIn order to effectivelt gain insights from their old paper records, organizations must transform them into a digital version.\nNow, simply making a digital copy of the document is actually rather easy; simply scan it, or even just upload a photo.\nThe problem though is that while this changes how the document is stored, it doesn't give us any real improvements to accessing the data therein.\nFor the longest time this required a laborious, manual, data entry process.\nSomeone would have to transcribe the documents, one-by-one, and enter each field into the books.\nThis presents a problem to organizations that potentially have thousands-upon-thousands of documents in their records: which can be intractable when it comes to the time and cost of the effort.\nLuckily though, there's a middle-ground."),(0,i.kt)("p",null,"Using Clarifai's publicly-available Optical Character Recognition (OCR) models, we can leverge Artifical Intelligence to both do this in a quick and cost-effective manner, but without sacraficing the insights they would have from recording every single value.  "),(0,i.kt)("h3",{id:"assumptions"},"Assumptions"),(0,i.kt)("p",null,"Before we begin, let us make some assumptions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},'The form is a standard for, with static regions for fixed values, ie the "name" field will always appear in the same location across all forms'),(0,i.kt)("li",{parentName:"ol"},"All of the entries will be in English, using the Roman alphabet"),(0,i.kt)("li",{parentName:"ol"},"The organization has a simple means of converting their paper documents to pdf documents, and storing them to a local file system; which is a common feature on most commercial print stations"),(0,i.kt)("li",{parentName:"ol"},"All of the forms will be type-filled, not handwritten; so as to make generating examples easier.")),(0,i.kt)("p",null,"These assumptions were largely made to make this example succinct and easily digestable."),(0,i.kt)("h2",{id:"setup"},"Setup"),(0,i.kt)("p",null,"Before we get to the implementation, let's take a moment to provide an overview thereof."),(0,i.kt)("p",null,"First off, the broad strokes have already been laid out: convert pdf to image, use Clarifai for OCR, and from that you'll have the text, which you then store in order to access later.\nClearly there are some gaps that need to be filled in though; the largest of which is just ",(0,i.kt)("em",{parentName:"p"},"how")," the document will be processed."),(0,i.kt)("p",null,"Working backwards a bit, the way in which the information will be recorded will be highly dependent on the organization's data policies.\nSo to simplify things, we will simply utilize Clarifai's platform to store the annotated documents."),(0,i.kt)("p",null,"Given assumption 1 above, we know that the fields will be in fixed locations.\nThis means we can define those ahead of time, and here we've chosen to do so using a JSON file, in which we define the document's structure in a manner similar to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "field_1": [0.25, 0.25, 0.50, 0.50],\n    "field_2": [0.50, 0.25, 0.75, 0.50],\n    .\n    .\n    .\n    "field_n": [0.25, 0.75, 0.50, 1.00]\n}\n')),(0,i.kt)("p",null,"Each key-value pair in the JSON file corresponds to the field name, the key (",(0,i.kt)("inlineCode",{parentName:"p"},'"field_n"'),"), and the region coordinates in the form of $","[x_0, y_0, x_1, y_1]","$."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: All of the region coordinates on the Clarifai are relative, not pixel values.\nThis is important, as other image processing libraries might use the pixel values instead.\nWe will address converting between these values below.")),(0,i.kt)("p",null,"Given that we know the name of the field, and where it is on the image, we can easily iterate through all of these field values, and annotate the corresponding region on the image. Having the coordinate values will also let us take sub-crops of the document to use the OCR model to predict on; isolating the text associated with a given field."),(0,i.kt)("p",null,"With this, we have a more fleshed out plan:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"We assume that the user is already familiar with basic platform usage, and has an account.\nIf more information is needed here, please find the appropriate section of the document in order to access more indepth information.")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Convert PDF to Image, and upload it the the Clarifai platform for storage."),(0,i.kt)("li",{parentName:"ol"},"Read values from the JSON where the form's fields and their locations are defined."),(0,i.kt)("li",{parentName:"ol"},"For each field and region:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Extract a sub-crop for the field"),(0,i.kt)("li",{parentName:"ul"},"Use Clarifai's OCR model to predict the text associated with the field"),(0,i.kt)("li",{parentName:"ul"},"Write the predicted text back to the input as an annotation")))),(0,i.kt)("p",null,"Now let's dive into the implementation:"),(0,i.kt)("p",null,"Starting with the conversion of a PDF document to an image, we can handle this with the open-source library ",(0,i.kt)("inlineCode",{parentName:"p"},"pdf2image"),"; which does exactly what the name suggests.\nIn order to be a bit more defensive with our programming we with wrap the call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"pdf2image.convert_from_path")," method in a separate function, and do some quick sanity checking to make sure the PDF file exists."),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"Python",label:"Python",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'import os\n\nfrom pdf2image import convert_from_path\n\ndef pdf_to_page_images(file_path):\n    """return an iterable of images that span the pages of the document"""\n    assert os.path.exists(file_path), f"file not found: {file_path}"\n    pdf_images = convert_from_path(file_path)\n\n    return pdf_images\n')))),(0,i.kt)("p",null,"This will return an iterable of images that correspond to the individual pages of the document."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: For simplicity's sake, our form only has one page.")),(0,i.kt)("h2",{id:"full-implementation"},"Full implementation"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"intelligent_document_processing.py",label:"intelligent_document_processing.py",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'#!/usr/bin/env python3\nimport io\nimport os\nimport json\nimport time\nimport argparse\n\nfrom pdf2image import convert_from_path\nfrom clarifai_grpc.channel.clarifai_channel import ClarifaiChannel\nfrom clarifai_grpc.grpc.api import resources_pb2, service_pb2, service_pb2_grpc\nfrom clarifai_grpc.grpc.api.status import status_pb2, status_code_pb2\n\n\ndef pdf_to_page_images(file_path):\n    """return an iterable of images that span the pages of the document"""\n    assert os.path.exists(file_path), f"file not found: {file_path}"\n    pdf_images = convert_from_path(file_path)\n\n    return pdf_images\n\ndef post_image_bytes_as_input(image_bytes, stub, metadata):\n    """post an image in bytes format to the platform as an input"""\n    post_inputs_response = stub.PostInputs(  # what is an intellgent way to handle these platform objects? Obvi singleton object that acts as a unified permissions manager...  \n        service_pb2.PostInputsRequest(\n            inputs=[\n                resources_pb2.Input(\n                    data=resources_pb2.Data(\n                        image=resources_pb2.Image(\n                            base64=image_bytes\n                        )\n                    )\n                ) \n            ]    \n        ),\n        metadata=metadata\n    )\n\n    return post_inputs_response\n\ndef image_to_bytes(img):\n    """convert a PIL image object to a byte array"""\n    byte_arr = io.BytesIO()\n    img.save(byte_arr, format=\'PNG\')\n    return byte_arr.getvalue()\n\ndef pixels_to_proportions(coordinates, image):\n    """\n    This function expects a sequence of coordinates as inputs, along with the image it corresponds to.\n    That is, something like: $[(x_0, y_0), (x_1, y_1), ..., (x_n, y_n)]$\n    """\n    w, h = image.size\n    output = []\n\n    for (x, y) in coordinates:\n        # x /= w\n        # y /= h\n        output.append((x/w, y/h))\n\n    return output\n\n\ndef proportions_to_pixels(coordinates, image):\n    """see docstring for `pixels_to_proportions`"""\n    w, h = image.size\n    output = []\n    for (x, y) in coordinates:\n        output.append((x*w, y*h))\n\n    return output\n\ndef unpack_tuple_list(a):\n    """flatten a nested list. Currently fixed at a depth of k=2."""\n    return [i for sub in a for i in sub]\n\ndef grouped(iterable, n):\n    """h/t https://stackoverflow.com/a/5389547\n    Given the iterable `S`, and the integer n\n    $S \\to (s_{0,0}, s_{0,1}, s_{0,2}, \\dots, s_{0, n-1}), \\ldots, (s_{m,0}, s_{m,1} , s_{m,2},...s_{m, n-1})$\n    """\n    return zip(*[iter(iterable)]*n)\n\ndef read_json_fields(json_file):\n    """\n    parse the document fields defined in json_file\n    """\n    with open(json_file, \'rb\') as f:\n        d = json.load(f)\n\n    for k, v in d.items():\n        yield k, v\n\n\ndef _hold_for_upload(asset_id, stub, metadata, t=.5):\n    """function that will halt the program while we wait for the input to finish uploading"""\n    from itertools import count\n    for i in count():\n        get_inputs_response = stub.GetInput(\n            request=service_pb2.GetInputRequest(\n                input_id=asset_id,\n            ),\n            metadata=metadata\n        )\n        assert get_inputs_response.status.code == status_code_pb2.SUCCESS\n\n        if get_inputs_response.input.status.code == status_code_pb2.INPUT_DOWNLOAD_SUCCESS:\n            break\n        else:\n            time.sleep(t)\n            continue\n\n    return True \n\n\ndef predict_text(image, model_id, stub, metadata):\n    """return the text value output by the specified OCR model. This is """\n    image_bytes = image_to_bytes(image)\n\n    post_model_outputs_response = stub.PostModelOutputs(\n        service_pb2.PostModelOutputsRequest(\n            model_id=model_id,\n            inputs=[\n                resources_pb2.Input(\n                    data=resources_pb2.Data(\n                        image=resources_pb2.Image(\n                            base64=image_bytes\n                        )\n                    )\n                )\n            ]\n        ),\n        metadata=metadata\n    )\n    if post_model_outputs_response.status.code != status_code_pb2.SUCCESS:\n        raise Exception("Post model outputs failed, status: " + post_model_outputs_response.status.description)\n\n    predicted_text = post_model_outputs_response.outputs[0].data.text.raw\n\n    return predicted_text\n\ndef make_concept(concept, value=1.):\n    """create a concept object. Note: By default this will create a positive association - value=1. - with the concept."""\n    return resources_pb2.Concept(id=concept, value=value)\n\ndef coords_to_bbox(x0, y0, x1, y1):\n    """create a BoundingBox object from a set of 2d Cartesian coordinates"""\n    return resources_pb2.BoundingBox(\n        left_col=x0,\n        top_row=y0,\n        right_col=x1,\n        bottom_row=y1\n    )\n\ndef make_annotation(input_id, coords, body, stub, metadata, *concepts):\n    """we\'re going to simply post a single region annotation at a time"""\n    post_annotations_response = stub.PostAnnotations(\n        service_pb2.PostAnnotationsRequest(\n            annotations=[\n                resources_pb2.Annotation(\n                    input_id=input_id,\n                    data=resources_pb2.Data(\n                        regions=[\n                            resources_pb2.Region(\n                                region_info=resources_pb2.RegionInfo(\n                                    bounding_box=coords_to_bbox(*coords),\n                                    text=resources_pb2.Text(raw=body)\n                                ),\n                                data=resources_pb2.Data(\n                                    concepts=[make_concept(concept) for concept in concepts],\n                                )\n                            )\n                        ]\n                    ),\n                ),\n            ]\n        ),\n        metadata=metadata\n    )\n\n    if post_annotations_response.status.code != status_code_pb2.SUCCESS:\n        raise Exception("Post annotations failed, status: " + post_annotations_response.status.description)    \n\n    return post_annotations_response\n\ndef main(args):\n    # initialize the Clarifai client\n    print(args)\n    channel = ClarifaiChannel.get_json_channel()\n    stub = service_pb2_grpc.V2Stub(channel)\n\n    metadata = ((\'authorization\', f\'Key {args.api_key}\'),)\n\n    # import the pdf document, and convert it to an iterable of images for the pages\n    doc, *_ = pdf_to_page_images(args.file) # we know our document is only one page, so we isolate the first item in the iterable. Isomorphic to pdf_to_page_images(args.file)[0]\n    doc_bytes = image_to_bytes(doc)\n\n    # post the doc as an input\n    post_input_response = post_image_bytes_as_input(doc_bytes, stub, metadata)\n\n    doc_id = post_input_response.inputs[0].id  # we know there will only be one input, given the setup above\n    \n    print(f"[DOC] - {doc_id}")\n    _ = _hold_for_upload(doc_id, stub, metadata)  # ensure that the input is uploaded, so that we can annotate the regions-of-interest\n\n    doc_fields = read_json_fields(args.layout)    \n\n    for field, value in doc_fields:\n        relative_coords = grouped(value, 2)  # xy-coords -> n=2\n        pixel_coords = proportions_to_pixels(relative_coords, doc)\n        pixel_coords_flat = unpack_tuple_list(pixel_coords)\n\n        # get a crop of the region\n        region = doc.crop(pixel_coords_flat)\n\n        # predicted text in cropped region\n        predicted_text = predict_text(region, args.model_id, stub, metadata)\n        print("\\t-", f"{field} | {predicted_text}")\n\n        post_annotation_response = make_annotation(doc_id, tuple(value), predicted_text, stub, metadata, field)\n\n        if post_annotation_response.status.code != status_code_pb2.SUCCESS:\n            breakpoint()\n\n    print("Done.")\n\n\nif __name__ == "__main__":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\'-f\', \'--file\', type=str, help="File path to the PDF document you would like to parse and annotate.")\n    parser.add_argument(\'-k\', \'--api_key\', type=str, help="The Clarifai API key associate with your application.")\n    parser.add_argument(\'-m\', \'--model_id\', type=str, help="The ID of the Clarifai model you would like to use for OCR.", default=\'eng-ocr\')\n    parser.add_argument(\'-l\', \'--layout\', type=str, help="Path to the JSON file in which the document layout is defined.", default=\'assets/field_regions.json\')\n\n    args = parser.parse_args()\n\n    _ = main(args)\n\n')))))}f.isMDXComponent=!0}}]);