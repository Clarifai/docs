"use strict";(self.webpackChunkdocs_new=self.webpackChunkdocs_new||[]).push([[8054],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),h=r,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||o;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},65124:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(67294),r=n(44996);function o(e){let{src:t,caption:n}=e;return a.createElement("figure",{style:{border:"1px dashed rgba(0, 0, 0, .1)",padding:20,borderRadius:"15px"}},a.createElement("img",{src:(0,r.Z)(t),alt:n}),a.createElement("hr",{style:{margin:"5px",backgroundColor:"rgba(0, 0, 0, .2)"}}),a.createElement("figcaption",{style:{marginTop:"0px"}},`${n}`))}},25116:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905)),o=n(65124);const i={description:"How to Add AI to a Node.js web app",sidebar_position:2},s="Add AI to a Node.js Web App",l={unversionedId:"tutorials/node-js-tutorial",id:"tutorials/node-js-tutorial",title:"Add AI to a Node.js Web App",description:"How to Add AI to a Node.js web app",source:"@site/docs/tutorials/node-js-tutorial.mdx",sourceDirName:"tutorials",slug:"/tutorials/node-js-tutorial",permalink:"/tutorials/node-js-tutorial",draft:!1,editUrl:"https://github.com/Clarifai/docs/blob/main/docs/tutorials/node-js-tutorial.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{description:"How to Add AI to a Node.js web app",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Get Started With Community Portal",permalink:"/clarifai-basics/community"},next:{title:"How to Evaluate An Image Classification Model",permalink:"/tutorials/how-to-evaluate-an-image-classification-model"}},p={},c=[{value:"Background &amp; Project Setup",id:"background--project-setup",level:2},{value:"Camera Preview and Taking a Photo",id:"camera-preview-and-taking-a-photo",level:2},{value:"Create a Personal Access Token",id:"create-a-personal-access-token",level:2},{value:"Create an API Handler",id:"create-an-api-handler",level:2},{value:"Calling our API",id:"calling-our-api",level:2},{value:"Calling an AI model",id:"calling-an-ai-model",level:2},{value:"Extracting Image Data from Request",id:"extracting-image-data-from-request",level:2},{value:"Summary",id:"summary",level:2}],d={toc:c},u="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"add-ai-to-a-nodejs-web-app"},"Add AI to a Node.js Web App"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"A step-by-step guide by Alexandros Katechis")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Clarifai makes it easy to train and deploy a model at scale in production, without having to think about provisioning GPUs or moving data around for training. In this blog post, we\u2019ll walk through how to bootstrap a new Javascript/Typescript web app, capture a photo of ourselves, and then use Clarifai\u2019s celebrity model to tell us which celebrity the user looks like."),(0,r.kt)("p",null,"There are many different web frameworks you could use (",(0,r.kt)("a",{parentName:"p",href:"https://expressjs.com/"},"express"),", ",(0,r.kt)("a",{parentName:"p",href:"https://koajs.com/"},"koa"),", ",(0,r.kt)("a",{parentName:"p",href:"https://nextjs.org/"},"next"),", ",(0,r.kt)("a",{parentName:"p",href:"https://remix.run/"},"remix"),"), and just as many UI libraries (",(0,r.kt)("a",{parentName:"p",href:"https://reactjs.org/"},"react"),", ",(0,r.kt)("a",{parentName:"p",href:"https://angular.io/"},"angular"),", ",(0,r.kt)("a",{parentName:"p",href:"https://vuejs.org/"},"vue"),", ",(0,r.kt)("a",{parentName:"p",href:"https://svelte.dev/"},"svelte"),"). In this blog post, we\u2019re going to go with next JS, which is the framework we use at Clarifai to build our web applications, but you could just as easily follow along with any other node.js framework you prefer, substituting your framework\u2019s conventions as we go along."),(0,r.kt)("p",null,"The final version of this project is available on Github, so if you run into any issues, feel free to clone the project repo, or open an issue. With that out of the way, let\u2019s get started!"),(0,r.kt)("h2",{id:"background--project-setup"},"Background & Project Setup"),(0,r.kt)("p",null,"We\u2019ll start with bootstrapping a new node.js web app. We\u2019re going to assume you already have node.js and git installed, if not, pause here and get those installed. Now that we\u2019re ready, start by running create-next-app to bootstrap a new project."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx create-next-app\n")),(0,r.kt)("p",null,"The CLI will ask us a few questions about what technology we want to use, we\u2019ll use the defaults, which will set us up with Typescript and ESLint in addition to a default homepage, a server for creating custom API handlers to run code on our server, and everything needed to build and deploy our app."),(0,r.kt)("p",null,"Try it out with yarn dev (or npm, if you prefer). You should see the following in your terminal."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"> yarn dev\nyarn run v1.22.15\n$ next dev\nready - started server on 0.0.0.0:3000, url: http://localhost:3000\nevent - compiled client and server successfully in 2.3s (165 modules)\nwait  - compiling / (client and server)...\n")),(0,r.kt)("p",null,"Opening ",(0,r.kt)("a",{parentName:"p",href:"http://localhost:3000"},"http://localhost:3000")," in your browser, should render the following page."),(0,r.kt)(o.Z,{caption:"Default Next.js app homepage",src:"/img/nodejs-tutorial/nextjs-homepage.jpeg",mdxType:"Figure"}),(0,r.kt)("p",null,"Great! Let\u2019s get started building our AI-powered celebrity app."),(0,r.kt)("h2",{id:"camera-preview-and-taking-a-photo"},"Camera Preview and Taking a Photo"),(0,r.kt)("p",null,"Open ",(0,r.kt)("inlineCode",{parentName:"p"},"pages/index.tsx")," where you will find all the React code for rendering the home page of our new app. You should see a bunch of markup for rendering next.js promotional content. Let\u2019s start by deleting it, and inserting some basic markup with a title, some instructions on how to use the app, and a ",(0,r.kt)("inlineCode",{parentName:"p"},"<video>")," element that we\u2019ll use to render a preview of our webcam."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="pages/index.tsx"',title:'"pages/index.tsx"'},'<>\n  <Head>\n    <title>Which Celebrity Am I?</title>\n    <meta name="description" content="Use the power of AI to figure out which celebrity you look like!" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <link rel="icon" href="/favicon.ico" />\n  </Head>\n  <main className={styles.main}>\n    <div className={styles.description}>\n      <h1>Which Celebrity Do you look like?</h1>\n      <a onClick={beginCapture}>Click to take a photo of yourself!</a>\n    </div>\n    <video className={styles.video} ref={cameraPreviewEl} />\n  </main>\n</>\n')),(0,r.kt)("p",null,"And the following CSS in ",(0,r.kt)("inlineCode",{parentName:"p"},"pages/index.tsx")," will help us add some basic styling"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css",metastring:'title="pages/index.tsx"',title:'"pages/index.tsx"'},".main {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  align-items: center;\n  padding: 6rem;\n  min-height: 100vh;\n}\n\n.description {\n  font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;\n  width: 100%;\n  justify-content: center;\n  text-align: center;\n}\n\n.description h1 {\n  font-size: 82px;\n  margin-bottom: 30px;\n}\n\n.description a {\n  font-size: 30px;\n  cursor: pointer;\n  text-decoration: underline;\n}\n\n.video {\n  width: 800px;\n  height: 600px;\n  border: 1px dashed #fff;\n}\n")),(0,r.kt)("p",null,"Finally, let\u2019s add an element ref and a click handler to request the user\u2019s permission to open their webcam, and render a preview in the page."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const cameraPreviewEl = useRef<HTMLVideoElement>(null);\n\nconst beginCapture = useCallback(\n  async () => {\n    if (!cameraPreviewEl.current) {\n      return;\n    }\n    const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n    cameraPreviewEl.current.srcObject = stream;\n    cameraPreviewEl.current.play();\n  },\n  [cameraPreviewEl]\n);\n")),(0,r.kt)("p",null,"What this callback does is first, make sure we have a reference to the video element. Line 8 requests access to a media device that can produce a video stream, represented by a ",(0,r.kt)("inlineCode",{parentName:"p"},"MediaStream")," object. Line 9 connects the video element to the media stream, and line 9 begins playback."),(0,r.kt)("p",null,"Once you save everything, the development server will automatically re-render the react components in your browser, without even refreshing the page, and the result should be something like the following."),(0,r.kt)(o.Z,{caption:"Our Celebrity App\u2019s initial render result",src:"/img/nodejs-tutorial/celeb-initial.jpeg",mdxType:"Figure"}),(0,r.kt)("p",null,"After clicking the link to open the user\u2019s webcam, and granting permission, we should see the following (your face may be different than mine)."),(0,r.kt)(o.Z,{caption:"Our Celebrity App\u2019s initial render result",src:"/img/nodejs-tutorial/celeb-result.jpeg",mdxType:"Figure"}),(0,r.kt)("p",null,"Great! Now that we have a webcam stream, we\u2019ll add a button that the user can click in order to take a snapshot. We only want to show the button when the camera is capturing, so let\u2019s add a bit of state to our component to represent that."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const [capturing, setCapturing] = useState(false);\n")),(0,r.kt)("p",null,"Next, let\u2019s update our click handler to set the flag to true once the video element has begun playback from the camera."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"setCapturing(true);\n")),(0,r.kt)("p",null,"Now that the flag is correctly being updated, let\u2019s add the conditional markup to render the button with some styling associated with it. For brevity, we\u2019ll just use an emoji of a camera with a flash, but you can use whatever icon component you may have handy."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"/* in our component */\n{capturing &&\n  (\n    <button className={styles.snapshot}>\n      \ud83d\udcf8\n    </button>\n  )}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css"},"/* in our css */\n.snapshot {\n  font-size: 65px;\n  background: none;\n  padding: 10px;\n  border: 1px solid #fff;\n  cursor: pointer;\n}\n")),(0,r.kt)("p",null,"Next, let\u2019s attach a click handler to the button to take a snapshot by drawing to an off-screen canvas element."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const takeSnapshot = useCallback(\n  () => {\n    if (!cameraPreviewEl.current) {\n      return;\n    }\n    const canvas = document.createElement('canvas');\n    canvas.width = 800;\n    canvas.height = 600;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      return;\n    }\n\n    ctx.drawImage(cameraPreviewEl.current, 0, 0, canvas.width, canvas.height);\n    // const dataUrl = canvas.toDataURL('image/jpeg');\n    // document.getElementById('frame').src = dataUrl;\n    // console.log(dataUrl);\n  },\n  []\n);\n")),(0,r.kt)("p",null,"This code should be pretty straight forward. We start by ensuring we have a reference to the video element, and creating a ",(0,r.kt)("inlineCode",{parentName:"p"},"canvas")," element in memory. We set it\u2019s dimensions to ",(0,r.kt)("inlineCode",{parentName:"p"},"800x600")," which will match the ",(0,r.kt)("inlineCode",{parentName:"p"},"<video>")," preview element we created earlier. To draw to a canvas element, we need to get a ",(0,r.kt)("inlineCode",{parentName:"p"},"CanvasRenderingContext2D")," object, which we acquire on line 10. If that succeeds, line 15 renders the video element\u2019s video track (don\u2019t forget, it also has an audio track which we don\u2019t care about for this app)."),(0,r.kt)("p",null,"Lines 16-18 are commented out, but if you want to preview what the snapshot looks like, you could uncomment them (and also add an ",(0,r.kt)("inlineCode",{parentName:"p"},'<img id="frame" width={800} height={600} />')," element to the markup), to see what your camera captured when you clicked the snapshot button."),(0,r.kt)("p",null,"For now, we\u2019ll leave the client side code as is, and turn our attention to the server side code."),(0,r.kt)("h2",{id:"create-a-personal-access-token"},"Create a Personal Access Token"),(0,r.kt)("p",null,"Refer to Clarifai\u2019s docs site for ",(0,r.kt)("a",{parentName:"p",href:"https://docs.clarifai.com/clarifai-basics/authentication/personal-access-tokens"},"instructions on creating a personal access token"),". A PAT is similar to an API key, insomuch that it can be used in the same way as an App key. The main advantage is that a PAT is allowed to access resources in all of our apps, as well as the clarifai/main app, which is where the Celebrity model we\u2019re interested in exists."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Your PAT can be used to call the Clarifai API on your behalf. For this reason, you should never include a PAT in your client-side code, like react components. Any user with dev tools open would be able to steal it and call the Clarifai API on your behalf.\nx\nFor this reason, we\u2019ll introduce an API handler that will call the Clarifai model from our server, and simply send a response to the client containing the result data we\u2019re interested in.")),(0,r.kt)("h2",{id:"create-an-api-handler"},"Create an API Handler"),(0,r.kt)("p",null,"You may have noticed earlier, that all the react code we were working with, was in ",(0,r.kt)("inlineCode",{parentName:"p"},"pages/index.tsx")," and it rendered on the path ",(0,r.kt)("inlineCode",{parentName:"p"},"/"),". If we were to create a react component at ",(0,r.kt)("inlineCode",{parentName:"p"},"pages/hello.tsx")," it would render on the path ",(0,r.kt)("inlineCode",{parentName:"p"},"/hello"),". This is ",(0,r.kt)("a",{parentName:"p",href:"https://nextjs.org/docs/basic-features/pages"},"NextJS's convention of filesystem-based routing"),". NextJS has a similar convention for creating ",(0,r.kt)("a",{parentName:"p",href:"https://nextjs.org/docs/api-routes/introduction"},"API handlers"),", under the ",(0,r.kt)("inlineCode",{parentName:"p"},"pages/api")," directory. We\u2019re going to create our handler under ",(0,r.kt)("inlineCode",{parentName:"p"},"pages/api/which-celebrity.ts")," which means we\u2019ll be able to call it by making a request to ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/which-celebrity"),". We already have a sample API handler in ",(0,r.kt)("inlineCode",{parentName:"p"},"hello.ts"),", thanks to ",(0,r.kt)("inlineCode",{parentName:"p"},"create-next-app")," so we\u2019ll just rename it to ",(0,r.kt)("inlineCode",{parentName:"p"},"which-celebrity")," and we\u2019ll be good to go."),(0,r.kt)(o.Z,{caption:"NextJS is even nice enough to tell us we look like \u201cJohn Doe\u201d",src:"/img/nodejs-tutorial/nextjs.jpeg",mdxType:"Figure"}),(0,r.kt)("p",null,"Next, let\u2019s create a typescript declaration file where we\u2019ll define an interface for our API\u2019s response. We\u2019ll create ",(0,r.kt)("inlineCode",{parentName:"p"},"types.ts")," in our project\u2019s root, and insert the following type declaration"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * If Clarifai can match us with a celebrity, return the name and score.\n * Otherwise, just return `false`.\n */\ntype WhichCelebrityResponse = {\n  recognized: typeof true;\n  name: string;\n  score: number;\n} | {\n  recognized: typeof false;\n}\n")),(0,r.kt)("p",null,"In a more complex project, you might even want to organize types in a more sophisticated way. In the case of this API response, the Clarifai model either recognizes us or not. If it does recognize us, we\u2019ll return a name and score alongside the flag. Now we can update our handler\u2019s response type to match this type, and we\u2019ll add some randomization to see both kinds of responses."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { WhichCelebrityResponse } from '@/types';\nimport type { NextApiRequest, NextApiResponse } from 'next'\n\nexport default function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<WhichCelebrityResponse>\n) {\n  if (req.method !== 'POST') {\n    console.warn(`Method ${req.method} not allowed for endpoint /which-celebrity!`);\n    return res.status(405).end();\n  }\n  const score = Math.random();\n  const response: WhichCelebrityResponse = score > 0.7\n    ? { name: 'John Doe', score, recognized: true }\n    : { recognized: false };\n\n  res.status(200).json(response);\n}\n")),(0,r.kt)("p",null,"By specifying the generic type parameter on line 6, the ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," method restricts the kind of data that we can return. We start by checking to see that the method is ",(0,r.kt)("inlineCode",{parentName:"p"},"POST"),", since this handler will need to receive the image data. Therefore, we start by checking to ensure we didn\u2019t incorrectly send a ",(0,r.kt)("inlineCode",{parentName:"p"},"GET")," request to ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/which-celebrity"),". On lines 12-17, we create a pseudo-random score, and if it\u2019s greater than ",(0,r.kt)("inlineCode",{parentName:"p"},"0.7"),", we return the recognized response, otherwise, we return the unrecognized response."),(0,r.kt)("p",null,"Now that we have a mock API handler created, we can update our client side code to send the snapshot to the backend and receive a mock response. Once we have this set up, we\u2019ll be able to test our server side handler code directly by using our UI."),(0,r.kt)("h2",{id:"calling-our-api"},"Calling our API"),(0,r.kt)("p",null,"Since our React component is becoming a bit complex, let\u2019s create a separate module where we\u2019ll write an async function to call our API endpoint."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { WhichCelebrityResponse } from \"@/types\";\n\nexport async function postWhichCelebrity(snapshot: Blob): Promise<WhichCelebrityResponse> {\n  const formdata = new FormData();\n  formdata.set('snapshot', snapshot);\n\n  const request: RequestInit = {\n    method: 'POST',\n    body: formdata,\n  };\n\n  const resp = await fetch('/api/which-celebrity', request);\n  const json: WhichCelebrityResponse = await resp.json();\n  return json;\n}\n")),(0,r.kt)("p",null,"This function is pretty simple. It receives our snapshot as a ",(0,r.kt)("inlineCode",{parentName:"p"},"Blob")," object, which in ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Blob"},"the web platform"),", represents any kind of immutable raw binary data, and puts it into a ",(0,r.kt)("inlineCode",{parentName:"p"},"FormData")," object which will be used as the body of our request. We set the method to ",(0,r.kt)("inlineCode",{parentName:"p"},"POST")," and send it off to our API using the ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch")," function. After ",(0,r.kt)("inlineCode",{parentName:"p"},"await"),"ing the response, we parse it as JSON, and cast it to our ",(0,r.kt)("inlineCode",{parentName:"p"},"WhichCelebrityResponse")," type so that the caller of this function can access the data."),(0,r.kt)("p",null,"Let\u2019s add some state to the react component to store the blob and response, and update the ",(0,r.kt)("inlineCode",{parentName:"p"},"takeSnapshot")," handler to send a Blob from the canvas' buffer to our API handler:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// in our react component\nimport { WhichCelebrityResponse } from "@/types";\n\n// ...\n\nconst [response, setResponse] = useState<WhichCelebrityResponse>();\n\n// in takeSnapshot handler\ncanvas.toBlob(async (blob) => {\n  if (!blob) {\n    return null;\n  }\n  const resp = await postWhichCelebrity(blob);\n  setResponse(resp);\n  // console.log(resp);\n});\n')),(0,r.kt)("p",null,"After calling ",(0,r.kt)("inlineCode",{parentName:"p"},"drawImage"),", we call ",(0,r.kt)("inlineCode",{parentName:"p"},"toBlob"),", and pass it a callback which sends the blob to the ",(0,r.kt)("inlineCode",{parentName:"p"},"postWhichCelebrity")," function we wrote earlier. The response that comes back gets saved to the react component\u2019s state, so that it can re-render itself with the response. If we uncomment line 15, and click the snapshot button a few times, we should eventually see both kinds of responses."),(0,r.kt)(o.Z,{caption:"",src:"/img/nodejs-tutorial/nextjs2.jpeg",mdxType:"Figure"}),(0,r.kt)("p",null,"Now we\u2019d like to render the snapshot that we sent to our API, alongside the response. Let\u2019s create a new react component to encapsulate this as our Homepage component is already quite complex."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="components/CelebrityResult.tsx"',title:'"components/CelebrityResult.tsx"'},'// components/CelebrityResult.tsx\nimport Image from "next/image";\nimport { WhichCelebrityResponse } from \'@/types\';\nimport styles from \'styles/CelebrityResult.module.css\';\n\nexport interface CelebrityResultProps {\n  snapshot: string;\n  response?: WhichCelebrityResponse;\n}\n\nexport default function CelebrityResult(props: CelebrityResultProps): JSX.Element {\n  const thinking = !props.response;\n\n  let output = null;\n  if (props.response) {\n    output = !props.response.recognized\n      ? <p className={`${styles.output} ${styles.message}`}>Sorry, we have no idea who you are!</p>\n      : <p className={`${styles.output} ${styles.message}`}>There&apos;s a {(props.response.score * 100).toFixed(1)}% chance you&apos;re {props.response.name}!</p>;\n  }\n\n  return (\n    <div className={styles.result}>\n      <Image src={props.snapshot} alt="Preview" id="frame" width={800} height={600} />\n      { thinking && \n        <p className={`${styles.output} ${styles.thinking}`}>\ud83e\udde0</p>}\n      { output }\n    </div>\n  );\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css",metastring:'title="styles/CelebrityResult.module.css"',title:'"styles/CelebrityResult.module.css"'},"// styles/CelebrityResult.module.css\n.result {\n  position: relative;\n  font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;\n}\n\n.result img {\n  border: 1px solid #fff;\n}\n\n.output {\n  position: absolute;\n  font-size: 30px;\n  padding: 15px;\n  top: 235px;\n  left: 335px;\n  background: rgba(255, 255, 255, 0.4);\n  border: 1px solid #fff;\n}\n\n.thinking {\n  font-size: 65px;\n  border-radius: 65px;\n  animation-name: spin;\n  animation-duration: 1000ms;\n  animation-iteration-count: infinite;\n  animation-timing-function: linear;\n}\n\n@keyframes spin {\n  0% {\n      transform:scale(100%);\n  }\n  50% {\n      transform:scale(200%);\n  }\n  100% {\n    transform:scale(100%);\n  }\n}\n\n.message {\n  top: 235px;\n  left: 0;\n  width: 800px;\n  text-align: center;\n}\n")),(0,r.kt)("p",null,"This component receives a snapshot as a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," and an optional API response object. If it receives no response, it will assume it\u2019s pending, and render a brain emoji with an animation to show the user that something is happening. Once the response comes back, it will tell the user whether there\u2019s a celebrity name or not, and what the score was as a percentage."),(0,r.kt)("p",null,"Let\u2019s now create some state to store the snapshot in the parent component, and convert the Blob to an object URL which can be rendered in an image."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// add the following state to the Homepage component\nconst [snapshot, setSnapshot] = useState<string>();\n\n// update the callback for toBlob()\nif (!blob) {\n  return null;\n}\n\nif (snapshot) {\n  URL.revokeObjectURL(snapshot);\n}\nsetSnapshot(URL.createObjectURL(blob));\n\nconst resp = await postWhichCelebrity(blob);\nsetResponse(resp);\n\n// update the render block to include the new component when the blob URL exists\n{ snapshot && <CelebrityResult snapshot={snapshot} response={response} />}\n")),(0,r.kt)("h2",{id:"calling-an-ai-model"},"Calling an AI model"),(0,r.kt)("p",null,"With all the pieces in place, we are finally ready to add AI to our application! Let\u2019s add our PAT to our application using an environment variable. NextJS uses ",(0,r.kt)("inlineCode",{parentName:"p"},"dotenv")," to load ",(0,r.kt)("inlineCode",{parentName:"p"},".env.local")," files when they\u2019re present. When we deploy this application to a production server, we instead specify the PAT in our server (or if we\u2019re using something more sophisticated like Kubernetes, we might have a Helm template that specifies these secrets."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# substitute your real PAT in the .env.local file below. \nCLARIFAI_TOKEN=abc123\n")),(0,r.kt)("p",null,"Next, let\u2019s install the ",(0,r.kt)("inlineCode",{parentName:"p"},"clarifai-nodejs-grpc")," client which will let us call models, and ",(0,r.kt)("inlineCode",{parentName:"p"},"busboy")," which will let us parse the body of the request to access the image data in the request body. Since busboy doesn\u2019t have type definitions included, we\u2019ll have to install them separately from ",(0,r.kt)("inlineCode",{parentName:"p"},"@types/busboy"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"yarn add clarifai-nodejs-grpc busboy @types/busboy\n")),(0,r.kt)("p",null,"For more information, see ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/clarifai-nodejs-grpc"},"here.")),(0,r.kt)("h2",{id:"extracting-image-data-from-request"},"Extracting Image Data from Request"),(0,r.kt)("p",null,"First, we need to tell next.js not to parse the body of our request, using a page config object, since we\u2019ll parse it using the ",(0,r.kt)("inlineCode",{parentName:"p"},"busboy")," library."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// pages/api/which-celebrity.ts\nexport const config = {\n  api: {\n    bodyParser: false,\n  }\n};\n")),(0,r.kt)("p",null,"We\u2019ll create another utility function for extracting the binary data of the snapshot image."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="utils/getSnapshotFileFromRequestBody.ts"',title:'"utils/getSnapshotFileFromRequestBody.ts"'},"// utils/getSnapshotFileFromRequestBody.ts\nimport busboy from 'busboy';\nimport type { NextApiRequest } from 'next';\n\nexport async function getSnapshotFileFromRequestBody(req: NextApiRequest): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    const bb = busboy({\n      headers: req.headers,\n    });\n    bb.on('file', (_name, stream, _info) => {\n      const dataParts: Buffer[] = [];\n      stream.on('data', (buf) => {\n        dataParts.push(buf);\n      });\n      stream.on('end', () => {\n        resolve(Buffer.concat(dataParts));\n      });\n      stream.on('error', (e) => {\n        reject(e);\n      })\n    });\n    req.pipe(bb);\n  });\n}\n")),(0,r.kt)("p",null,"This function creates a new ",(0,r.kt)("inlineCode",{parentName:"p"},"busboy")," instance, and for each file it encounters in the request we pipe into it, it creates a new array to assemble all the parts of the file. Once it\u2019s done receiving these individual buffers, it concatenates them all into a single ",(0,r.kt)("inlineCode",{parentName:"p"},"Buffer")," that contains all of the image data."),(0,r.kt)("p",null,"Next, we\u2019ll create a separate module to contain all our Clarifai code. We\u2019ll create a static client object, and write a function that receives a ",(0,r.kt)("inlineCode",{parentName:"p"},"Buffer")," and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"WhichCelebrityResponse"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="utils/predictWhichCelebrity.ts"',title:'"utils/predictWhichCelebrity.ts"'},"// utils/predictWhichCelebrity.ts\nimport { WhichCelebrityResponse } from '@/types';\nimport { grpc } from 'clarifai-nodejs-grpc';\nimport { V2Client } from 'clarifai-nodejs-grpc/proto/clarifai/api/service_grpc_pb';\nimport { PostModelOutputsRequest } from 'clarifai-nodejs-grpc/proto/clarifai/api/service_pb';\nimport { Data, Input, UserAppIDSet, Image } from 'clarifai-nodejs-grpc/proto/clarifai/api/resources_pb';\n\nconst client = new V2Client('api.clarifai.com', grpc.ChannelCredentials.createSsl());\nconst MODEL_ID = 'celebrity-face-recognition';\n\nexport async function predictWhichCelebrity(file: Buffer): Promise<WhichCelebrityResponse> {\n  const req = new PostModelOutputsRequest();\n\n  const userAppIdSet = new UserAppIDSet();\n  userAppIdSet.setUserId('clarifai');\n  userAppIdSet.setAppId('main');\n\n  req.setUserAppId(userAppIdSet);\n  req.setModelId(MODEL_ID);\n\n  const input = fileToImage(file);\n  req.setInputsList([input]);\n\n  const metadata = new grpc.Metadata();\n  metadata.set('Authorization', `Key ${process.env.CLARIFAI_TOKEN}`);\n\n  return new Promise((resolve, reject) => {\n    client.postModelOutputs(req, metadata, (error, resp) => {\n      if (error) {\n        return reject(error);\n      }\n\n      const output = resp.getOutputsList()[0];\n\n      const concepts = output.getData()?.getConceptsList();\n      if (!concepts || concepts.length === 0) {\n        return resolve({ recognized: false });\n      }\n\n      const mostLikely = concepts[0];\n      if (mostLikely.getValue() > 0.7) {\n        const response: WhichCelebrityResponse = {\n          recognized: true,\n          name: concepts[0].getName(),\n          score: concepts[0].getValue(),\n        };\n        return resolve(response);\n      } else {\n        const response: WhichCelebrityResponse = {\n          recognized: false,\n        };\n        return resolve(response);\n      }\n    });\n  });\n}\n\nfunction fileToImage(file: Buffer): Input {\n  const input = new Input();\n  const data = new Data();\n  const img = new Image();\n  img.setBase64(file);\n  data.setImage(img);\n  input.setData(data);\n  return input;\n}\n")),(0,r.kt)("p",null,"This code is quite verbose, but also very straightforward. Our ",(0,r.kt)("inlineCode",{parentName:"p"},"predictWhichCelebrity")," function creates a new ",(0,r.kt)("inlineCode",{parentName:"p"},"PostModelOutputsRequest")," and we set the User ID and App ID and Model ID that we want to call. Remember, all of Clarifai\u2019s publicly available models live in the ",(0,r.kt)("a",{parentName:"p",href:"https://clarifai.com/clarifai/main"},"clarifai/main")," app. Next, we take the ",(0,r.kt)("inlineCode",{parentName:"p"},"Buffer")," parameter and package it into an ",(0,r.kt)("inlineCode",{parentName:"p"},"Input")," object which contains an Image data object. Finally, we create a ",(0,r.kt)("inlineCode",{parentName:"p"},"grpc.Metadata")," for passing our authentication information, before sending the request to Clarifai. Once the response comes back, we check for errors, and ensure that we got some ",(0,r.kt)("inlineCode",{parentName:"p"},"Concept")," back. In the Celebrity model, each \u201cconcept\u201d is a celebrity name, and the first concept is always the one with the highest value. If that concept\u2019s value is greater than ",(0,r.kt)("inlineCode",{parentName:"p"},"0.7")," we return the value and name of that celebrity, otherwise, we return ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"recognized")," property."),(0,r.kt)("p",null,"With these two functions, we can replace the mock implementation of our API handler, by simply calling these two functions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="pages/api/which-celebrity.ts"',title:'"pages/api/which-celebrity.ts"'},"// pages/api/which-celebrity.ts\nconst file = await getSnapshotFileFromRequestBody(req);\nconst resp = await predictWhichCelebrity(file);\n\nres.status(200).json(resp);\n")),(0,r.kt)(o.Z,{caption:"",src:"/img/nodejs-tutorial/final-result.jpeg",mdxType:"Figure"}),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"In this tutorial, we went from zero to AI hero using Clarifai\u2019s world-class models. We created a new web application with Next.js, learned how to access a user\u2019s webcam, and call an AI model to see if we look like any celebrities. For the full project, see the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Clarifai/which-celebrity-app"},"Github repo"),", or try it out live on Vercel, and if you encountered any trouble while following along, feel free to open an issue on the repo so we can fix it."),(0,r.kt)("p",null,"We look forward to seeing what our community builds with Clarifai!"))}h.isMDXComponent=!0}}]);