"use strict";(self.webpackChunkdocs_new=self.webpackChunkdocs_new||[]).push([[1303],{8215:function(e,t,n){var a=n(7294);t.Z=function(e){var t=e.children,n=e.hidden,o=e.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:o},t)}},6396:function(e,t,n){n.d(t,{Z:function(){return c}});var a=n(7462),o=n(7294),i=n(2389),s=n(9443);var r=function(){var e=(0,o.useContext)(s.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},l=n(3616),d=n(6010),p="tabItem_vU9c";function u(e){var t,n,i,s=e.lazy,u=e.block,c=e.defaultValue,m=e.values,h=e.groupId,f=e.className,_=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=m?m:_.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),v=(0,l.lx)(g,(function(e,t){return e.value===t.value}));if(v.length>0)throw new Error('Docusaurus error: Duplicate values "'+v.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var b=null===c?c:null!=(t=null!=c?c:null==(n=_.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(i=_[0])?void 0:i.props.value;if(null!==b&&!g.some((function(e){return e.value===b})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+b+'" but none of its children has the corresponding value. Available values are: '+g.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var k=r(),y=k.tabGroupChoices,w=k.setTabGroupChoices,x=(0,o.useState)(b),N=x[0],C=x[1],T=[],I=(0,l.o5)().blockElementScrollPositionUntilNextRender;if(null!=h){var P=y[h];null!=P&&P!==N&&g.some((function(e){return e.value===P}))&&C(P)}var S=function(e){var t=e.currentTarget,n=T.indexOf(t),a=g[n].value;a!==N&&(I(t),C(a),null!=h&&w(h,a))},z=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a=T.indexOf(e.currentTarget)+1;n=T[a]||T[0];break;case"ArrowLeft":var o=T.indexOf(e.currentTarget)-1;n=T[o]||T[T.length-1]}null==(t=n)||t.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,d.Z)("tabs",{"tabs--block":u},f)},g.map((function(e){var t=e.value,n=e.label,i=e.attributes;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:N===t?0:-1,"aria-selected":N===t,key:t,ref:function(e){return T.push(e)},onKeyDown:z,onFocus:S,onClick:S},i,{className:(0,d.Z)("tabs__item",p,null==i?void 0:i.className,{"tabs__item--active":N===t})}),null!=n?n:t)}))),s?(0,o.cloneElement)(_.filter((function(e){return e.props.value===N}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},_.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==N})}))))}function c(e){var t=(0,i.Z)();return o.createElement(u,(0,a.Z)({key:String(t)},e))}},3918:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return u},default:function(){return f},frontMatter:function(){return p},metadata:function(){return c},toc:function(){return m}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),s=n(6396),r=n(8215),l=n(9055),d=["components"],p={description:"Capture information from an organization's form that are stored as PDF documents.",sidebar_position:5},u="Intelligent Document Processing",c={unversionedId:"api-guide/advanced-topics/intelligent-document-processing",id:"api-guide/advanced-topics/intelligent-document-processing",title:"Intelligent Document Processing",description:"Capture information from an organization's form that are stored as PDF documents.",source:"@site/docs/api-guide/advanced-topics/intelligent-document-processing.md",sourceDirName:"api-guide/advanced-topics",slug:"/api-guide/advanced-topics/intelligent-document-processing",permalink:"/api-guide/advanced-topics/intelligent-document-processing",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api-guide/advanced-topics/intelligent-document-processing.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{description:"Capture information from an organization's form that are stored as PDF documents.",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Batch Predict CSV on Custom Text Model",permalink:"/api-guide/advanced-topics/batch-predict-csv-on-custom-text-model"},next:{title:"Clarifai Portal Basics",permalink:"/portal-guide/portal-overview"}},m=[{value:"Introduction",id:"introduction",children:[{value:"The Use Case",id:"the-use-case",children:[],level:3},{value:"Assumptions",id:"assumptions",children:[],level:3}],level:2},{value:"Setup",id:"setup",children:[],level:2},{value:"Full implementation",id:"full-implementation",children:[],level:2}],h={toc:m};function f(e){var t=e.components,n=(0,o.Z)(e,d);return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"intelligent-document-processing"},"Intelligent Document Processing"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Capture information from an organization's form that are stored as PDF documents")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In this series of posts, advanced users at Clarifai will present working solutions to help you kick-start your own AI solutions.")),(0,i.kt)("h3",{id:"the-use-case"},"The Use Case"),(0,i.kt)("p",null,"There is a problem facing many organizations as they attempt to modernize: digitizing documents.\nIn order to effectively gain insights from their old paper records, organizations must transform them into digital versions."),(0,i.kt)("p",null,"Now, simply making a digital copy of a document is actually rather easy\u2060\u2014simply scan it or take its photo.\nThe problem, though, is that while this changes how the document is stored, it doesn't give you any real improvements to accessing the data therein."),(0,i.kt)("p",null,"Previously, this required a laborious, manual, data entry process. Someone would have to transcribe the documents one-by-one, and enter each field into the books.\nThis presents a problem to organizations that potentially have thousands and thousands of documents in their records, which can be intractable when it comes to the time and cost of the effort.\nLuckily, there's a middle-ground."),(0,i.kt)("p",null,"Using Clarifai's publicly available Optical Character Recognition (OCR) models, organizations can leverage Artifical Intelligence to both do this in a quick and cost-effective manner, and without sacrificing the insights they would have from recording every single value.  "),(0,i.kt)("h3",{id:"assumptions"},"Assumptions"),(0,i.kt)("p",null,"Before we begin, let us make some assumptions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},'The forms are standardized with static regions for fixed values; for example, the "name" field will always appear in the same location across all forms;'),(0,i.kt)("li",{parentName:"ol"},"All the entries will be in English, using the Roman alphabet;"),(0,i.kt)("li",{parentName:"ol"},"The organizations have a simple means of converting their paper documents to pdf documents, and storing them to a local file system, which is a common feature on most commercial print stations;"),(0,i.kt)("li",{parentName:"ol"},"All the forms will be type-filled, not handwritten, so as to make generating examples easier.")),(0,i.kt)("p",null,"These assumptions were largely made to make this example succinct and easily digestable."),(0,i.kt)("h2",{id:"setup"},"Setup"),(0,i.kt)("p",null,"Before we get to the implementation, let's take a moment to provide an overview thereof."),(0,i.kt)("p",null,"First off, the broad strokes have already been laid out: convert pdf to image, use Clarifai for OCR, and from that you'll have the text, which you then store in order to access later.\nClearly, there are some gaps that need to be filled in though\u2060\u2014the largest of which is just ",(0,i.kt)("em",{parentName:"p"},"how")," the document will be processed."),(0,i.kt)("p",null,"Working backwards a bit, the way in which the information will be recorded will be highly dependent on the organization's data policies.\nSo to simplify things, we will utilize Clarifai's platform to store the annotated documents."),(0,i.kt)("p",null,"Given assumption 1 above, we know that the fields will be in fixed locations.\nThis means we can define those ahead of time, and here we've chosen to do so using a JSON file, in which we define the document's structure in a manner similar to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "field_1": [0.25, 0.25, 0.50, 0.50],\n    "field_2": [0.50, 0.25, 0.75, 0.50],\n    .\n    .\n    .\n    "field_n": [0.25, 0.75, 0.50, 1.00]\n}\n')),(0,i.kt)("p",null,"Each key-value pair in the JSON file corresponds to the field name, the key (",(0,i.kt)("inlineCode",{parentName:"p"},'"field_n"'),"), and the region coordinates in the form of $","[x_0, y_0, x_1, y_1]","$."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"All the region coordinates on Clarifai are relative, not pixel values. This is important, as other image processing libraries might use the pixel values instead.\nWe will address converting between these values below."))),(0,i.kt)("p",null,"Given that we know the name of the field, and where it is on the image, we can easily iterate through all of these field values, and annotate the corresponding region on the image. Having the coordinate values will also let us take sub-crops of the document to use the OCR model to predict on; isolating the text associated with a given field."),(0,i.kt)("p",null,"With this, we have a more fleshed out plan:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"We assume that the user is already familiar with basic platform usage, and has an account.\nIf more information is needed here, please find the appropriate section of the document in order to access more in-depth information.")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Convert PDF to Image, and upload it on the Clarifai platform for storage."),(0,i.kt)("li",{parentName:"ol"},"Read values from the JSON where the form's fields and their locations are defined."),(0,i.kt)("li",{parentName:"ol"},"For each field and region:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Extract a sub-crop for the field;"),(0,i.kt)("li",{parentName:"ul"},"Use Clarifai's OCR model to predict the text associated with the field;"),(0,i.kt)("li",{parentName:"ul"},"Write the predicted text back to the input as an annotation.")))),(0,i.kt)("p",null,"Now let's dive into the implementation:"),(0,i.kt)("p",null,"Starting with the conversion of a PDF document to an image, we can handle this with the open-source library ",(0,i.kt)("inlineCode",{parentName:"p"},"pdf2image"),", which does exactly what the name suggests."),(0,i.kt)("p",null,"In order to be a bit more defensive with our programming, we will wrap the call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"pdf2image.convert_from_path")," method in a separate function, and do some quick sanity checking to make sure the PDF file exists."),(0,i.kt)(s.Z,{mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"python",label:"Pythonz",default:!0,mdxType:"TabItem"},(0,i.kt)(l.Z,{className:"language-python",mdxType:"CodeBlock"},'import os\n\nfrom pdf2image import convert_from_path\n\ndef pdf_to_page_images(file_path):\n    """return an iterable of images that span the pages of the document"""\n    assert os.path.exists(file_path), f"file not found: {file_path}"\n    pdf_images = convert_from_path(file_path)\n\n    return pdf_images'))),(0,i.kt)("p",null,"This will return iterable images that correspond to the individual pages of the document."),(0,i.kt)("div",{className:"admonition admonition-important alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"For simplicity's sake, our form only has one page."))),(0,i.kt)("h2",{id:"full-implementation"},"Full implementation"),(0,i.kt)(s.Z,{mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"intelligent_document_processing.py",label:"intelligent_document_processing.py",mdxType:"TabItem"},(0,i.kt)(l.Z,{className:"language-python",mdxType:"CodeBlock"},'#!/usr/bin/env python3\nimport io\nimport os\nimport json\nimport time\nimport argparse\n\nfrom pdf2image import convert_from_path\nfrom clarifai_grpc.channel.clarifai_channel import ClarifaiChannel\nfrom clarifai_grpc.grpc.api import resources_pb2, service_pb2, service_pb2_grpc\nfrom clarifai_grpc.grpc.api.status import status_pb2, status_code_pb2\n\n\ndef pdf_to_page_images(file_path):\n    """return an iterable of images that span the pages of the document"""\n    assert os.path.exists(file_path), f"file not found: {file_path}"\n    pdf_images = convert_from_path(file_path)\n\n    return pdf_images\n\ndef post_image_bytes_as_input(image_bytes, stub, metadata):\n    """post an image in bytes format to the platform as an input"""\n    post_inputs_response = stub.PostInputs(  # what is an intellgent way to handle these platform objects? Obvi singleton object that acts as a unified permissions manager...  \n        service_pb2.PostInputsRequest(\n            inputs=[\n                resources_pb2.Input(\n                    data=resources_pb2.Data(\n                        image=resources_pb2.Image(\n                            base64=image_bytes\n                        )\n                    )\n                ) \n            ]    \n        ),\n        metadata=metadata\n    )\n\n    return post_inputs_response\n\ndef image_to_bytes(img):\n    """convert a PIL image object to a byte array"""\n    byte_arr = io.BytesIO()\n    img.save(byte_arr, format=\'PNG\')\n    return byte_arr.getvalue()\n\ndef pixels_to_proportions(coordinates, image):\n    """\n    This function expects a sequence of coordinates as inputs, along with the image it corresponds to.\n    That is, something like: $[(x_0, y_0), (x_1, y_1), ..., (x_n, y_n)]$\n    """\n    w, h = image.size\n    output = []\n\n    for (x, y) in coordinates:\n        # x /= w\n        # y /= h\n        output.append((x/w, y/h))\n\n    return output\n\n\ndef proportions_to_pixels(coordinates, image):\n    """see docstring for `pixels_to_proportions`"""\n    w, h = image.size\n    output = []\n    for (x, y) in coordinates:\n        output.append((x*w, y*h))\n\n    return output\n\ndef unpack_tuple_list(a):\n    """flatten a nested list. Currently fixed at a depth of k=2."""\n    return [i for sub in a for i in sub]\n\ndef grouped(iterable, n):\n    """h/t https://stackoverflow.com/a/5389547\n    Given the iterable `S`, and the integer n\n    $S \\to (s_{0,0}, s_{0,1}, s_{0,2}, \\dots, s_{0, n-1}), \\ldots, (s_{m,0}, s_{m,1} , s_{m,2},...s_{m, n-1})$\n    """\n    return zip(*[iter(iterable)]*n)\n\ndef read_json_fields(json_file):\n    """\n    parse the document fields defined in json_file\n    """\n    with open(json_file, \'rb\') as f:\n        d = json.load(f)\n\n    for k, v in d.items():\n        yield k, v\n\n\ndef _hold_for_upload(asset_id, stub, metadata, t=.5):\n    """function that will halt the program while we wait for the input to finish uploading"""\n    from itertools import count\n    for i in count():\n        get_inputs_response = stub.GetInput(\n            request=service_pb2.GetInputRequest(\n                input_id=asset_id,\n            ),\n            metadata=metadata\n        )\n        assert get_inputs_response.status.code == status_code_pb2.SUCCESS\n\n        if get_inputs_response.input.status.code == status_code_pb2.INPUT_DOWNLOAD_SUCCESS:\n            break\n        else:\n            time.sleep(t)\n            continue\n\n    return True \n\n\ndef predict_text(image, model_id, stub, metadata):\n    """return the text value output by the specified OCR model. This is """\n    image_bytes = image_to_bytes(image)\n\n    post_model_outputs_response = stub.PostModelOutputs(\n        service_pb2.PostModelOutputsRequest(\n            model_id=model_id,\n            inputs=[\n                resources_pb2.Input(\n                    data=resources_pb2.Data(\n                        image=resources_pb2.Image(\n                            base64=image_bytes\n                        )\n                    )\n                )\n            ]\n        ),\n        metadata=metadata\n    )\n    if post_model_outputs_response.status.code != status_code_pb2.SUCCESS:\n        raise Exception("Post model outputs failed, status: " + post_model_outputs_response.status.description)\n\n    predicted_text = post_model_outputs_response.outputs[0].data.text.raw\n\n    return predicted_text\n\ndef make_concept(concept, value=1.):\n    """create a concept object. Note: By default this will create a positive association - value=1. - with the concept."""\n    return resources_pb2.Concept(id=concept, value=value)\n\ndef coords_to_bbox(x0, y0, x1, y1):\n    """create a BoundingBox object from a set of 2d Cartesian coordinates"""\n    return resources_pb2.BoundingBox(\n        left_col=x0,\n        top_row=y0,\n        right_col=x1,\n        bottom_row=y1\n    )\n\ndef make_annotation(input_id, coords, body, stub, metadata, *concepts):\n    """we\'re going to simply post a single region annotation at a time"""\n    post_annotations_response = stub.PostAnnotations(\n        service_pb2.PostAnnotationsRequest(\n            annotations=[\n                resources_pb2.Annotation(\n                    input_id=input_id,\n                    data=resources_pb2.Data(\n                        regions=[\n                            resources_pb2.Region(\n                                region_info=resources_pb2.RegionInfo(\n                                    bounding_box=coords_to_bbox(*coords),\n                                    text=resources_pb2.Text(raw=body)\n                                ),\n                                data=resources_pb2.Data(\n                                    concepts=[make_concept(concept) for concept in concepts],\n                                )\n                            )\n                        ]\n                    ),\n                ),\n            ]\n        ),\n        metadata=metadata\n    )\n\n    if post_annotations_response.status.code != status_code_pb2.SUCCESS:\n        raise Exception("Post annotations failed, status: " + post_annotations_response.status.description)    \n\n    return post_annotations_response\n\ndef main(args):\n    # initialize the Clarifai client\n    print(args)\n    channel = ClarifaiChannel.get_json_channel()\n    stub = service_pb2_grpc.V2Stub(channel)\n\n    metadata = ((\'authorization\', f\'Key {args.api_key}\'),)\n\n    # import the pdf document, and convert it to an iterable of images for the pages\n    doc, *_ = pdf_to_page_images(args.file) # we know our document is only one page, so we isolate the first item in the iterable. Isomorphic to pdf_to_page_images(args.file)[0]\n    doc_bytes = image_to_bytes(doc)\n\n    # post the doc as an input\n    post_input_response = post_image_bytes_as_input(doc_bytes, stub, metadata)\n\n    doc_id = post_input_response.inputs[0].id  # we know there will only be one input, given the setup above\n    \n    print(f"[DOC] - {doc_id}")\n    _ = _hold_for_upload(doc_id, stub, metadata)  # ensure that the input is uploaded, so that we can annotate the regions-of-interest\n\n    doc_fields = read_json_fields(args.layout)    \n\n    for field, value in doc_fields:\n        relative_coords = grouped(value, 2)  # xy-coords -> n=2\n        pixel_coords = proportions_to_pixels(relative_coords, doc)\n        pixel_coords_flat = unpack_tuple_list(pixel_coords)\n\n        # get a crop of the region\n        region = doc.crop(pixel_coords_flat)\n\n        # predicted text in cropped region\n        predicted_text = predict_text(region, args.model_id, stub, metadata)\n        print("\\t-", f"{field} | {predicted_text}")\n\n        post_annotation_response = make_annotation(doc_id, tuple(value), predicted_text, stub, metadata, field)\n\n        if post_annotation_response.status.code != status_code_pb2.SUCCESS:\n            breakpoint()\n\n    print("Done.")\n\n\nif __name__ == "__main__":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\'-f\', \'--file\', type=str, help="File path to the PDF document you would like to parse and annotate.")\n    parser.add_argument(\'-k\', \'--api_key\', type=str, help="The Clarifai API key associate with your application.")\n    parser.add_argument(\'-m\', \'--model_id\', type=str, help="The ID of the Clarifai model you would like to use for OCR.", default=\'eng-ocr\')\n    parser.add_argument(\'-l\', \'--layout\', type=str, help="Path to the JSON file in which the document layout is defined.", default=\'assets/field_regions.json\')\n\n    args = parser.parse_args()\n\n    _ = main(args)\n'))))}f.isMDXComponent=!0}}]);